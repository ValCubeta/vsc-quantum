skip // breaks the current block

this
null

12345
12345.6789
123e456
123.456e789
0b10010
0x123ff
infy
nanu

({ name }) // { name: value }

"$(expression)"
"%%" // string receiver

/(?:)/

// operators
number + number
number - number
number * number
number / number
number ^ number
number % number
number ~ number -> Range
expression =(name)> expression // tube expression
receiver << value
value >> receiver
expression and expression // logical and
expression AND expression // binary and
expression or expression
expression OR expression
expression in iterable -> Boolean
value from class // instanceof
expression ?? expression
expression . property
expression ?. property
function ?. ()

expression ? expression | expression

// prefixes
- number
+ number
++ number // returns number + 1 and sets number to number + 1
-- number // returns number - 1 and sets number to number - 1

// suffixes
number ++ // returns number and sets number to number + 1
number -- // returns number and sets number to number - 1
expression [expression]

// keywords
delete name

async fun function(): do
generator fun function(): do
async generator fun function(): do

await asyncFunction!

if expression: do
else: do

with expression: do

when expression {
	... == "some": do
	is expression: do
	is a, b: do
	otherwise: do
}

foreach value in iterable {
	next
	break
}
foreach key, value of object: do
while expression: do
for i = 0, i <= 10, i++: do

return expression

do: do // eq. () =>

import file
import "path/to/file.extension"
import property from file
import * from file
import a, b, c

try: do
on name: do // catch

class ClassName? {
	publ static name = value
	publ name = value
	priv name = value

	publ {
		name  = value
		name  = value
	}

	static {
		publ {
			// ...
		}
		priv {
			// ...
		}
	}
}

// functions
print("string")
write("string")
isset(object.property)
typeof(value)
read!
exit(0)

// classes
Value

Boolean()
Number()
String()

new Object()
new Array()
new Function()
new Promise()
new RegExp()
new Date()
new Range() // number ~ number

// types
varbl name = value
varbl name: Type = value
const name = value
const name later
fun name(params): do
class Name: do

varbl a, b, c // unset
varbl a, b, c = c, b, a // reverse
varbl a = expression, b = expression
varbl { property, "invalid syntax" as validSyntax } = object // varbl [property, validSyntax] = [object.property, object["invalid syntax"]]
varbl [ property ] = array // varbl property = array[0]
varbl("invalid syntax")

u16
u32
u64

bit
i16
i32
i64
big

f32
f64

// other
import math /*{
	random()
	max()
	min()
}*/

import intl /*{
	numberFormat()       // ("es-es", 209329)    -> "209.329"
	dateTimeFormat()     // (new Date)           -> "02/05/2026 03:56 a. m."
	relativeTimeFormat() // ("es-es", 2, "days") -> "Pasado mañana"
	listFormat()         // ["a", "b", "c"]      -> "a, b, and c"
	compare()            // ("es-es", "Á", "a")  -> 0
	segment()            // split words ("Hello world" => ["Hello", "world"])
	char {
		isUpper()
		isLower()
		isDigit()
		isHexDigit()
		isSpace()
		isPrintable()
	}
}*/

async fun fetch(url) {
	doAsyncStuff()
}

do! {
	import fetch
	import parse from json
	fetch("8.8.8.8").then(res => (print) parse(res))
}

fun main!:
	print("Hello world!")